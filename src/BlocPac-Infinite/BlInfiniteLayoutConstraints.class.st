"
I am specific element constraints that should be used by infinite element and infinite layout.
Infinite layouts use me to store addition data assigned to children

"
Class {
	#name : #BlInfiniteLayoutConstraints,
	#superclass : #BlLayoutConstraints,
	#instVars : [
		'holder',
		'decorationInsets',
		'insertsDirty',
		'pendingInvalidate'
	],
	#category : #'BlocPac-Infinite-Layout'
}

{ #category : #accessing }
BlInfiniteLayoutConstraints >> decorationInsets [
	^ decorationInsets
]

{ #category : #'initialize-release' }
BlInfiniteLayoutConstraints >> defaultHolder [
	^ BlInfiniteHolder new
]

{ #category : #'accessing - position' }
BlInfiniteLayoutConstraints >> elementDataSourcePosition [
	"Returns the up-to-date datasource position that the element I am attached to corresponds to"
	<return: #Number>

	^ holder dataSourcePosition
]

{ #category : #'accessing - position' }
BlInfiniteLayoutConstraints >> elementLayoutPosition [
	"Returns the datasource position that the element I am attached to corresponds to as of latest layout calculation"
	<return: #Number>

	^ holder layoutPosition
]

{ #category : #accessing }
BlInfiniteLayoutConstraints >> holder [
	"Return an element holder of the element I am attached to.
	holder can not be nil"
	<return: #BlInfiniteHolder>

	^ holder
]

{ #category : #accessing }
BlInfiniteLayoutConstraints >> holder: anElementHolder [
	"Change an element holder of the element I am attached to.
	anElement holder must not be nil"
	
	self
		assert: [ anElementHolder isNotNil ]
		description: [ 'An element holder must not be nil' ].

	holder := anElementHolder
]

{ #category : #'initialize-release' }
BlInfiniteLayoutConstraints >> initialize [
	super initialize.
	
	holder := self defaultHolder.
	decorationInsets := BlInsets all: 0.
	pendingInvalidate := false
]

{ #category : #'private - accessing' }
BlInfiniteLayoutConstraints >> insetsDirty [
	^ insertsDirty
]

{ #category : #'private - accessing' }
BlInfiniteLayoutConstraints >> insetsDirty: aBoolean [
	insertsDirty := aBoolean
]

{ #category : #testing }
BlInfiniteLayoutConstraints >> isElementInvalid [
	"Returns true if the element I am attached to is now representing potentially invalid data.
	An InfiniteLayout should scrap/recycle it."
	<return: #Boolean>
	
	^ holder isInvalid
]

{ #category : #testing }
BlInfiniteLayoutConstraints >> isElementNeedsUpdate [
	"Returns true if the element I am attached to needs to have its content updated from the corresponding datasource"
	<return: #Boolean>

	^ holder needsUpdate
]

{ #category : #testing }
BlInfiniteLayoutConstraints >> isItemChanged [
	"Returns true if the datasource item corresponding to the element I am attached to has been changed in the data set.
	An InfiniteElement may choose to treat it differently in order to animate its changing state."
	<return: #Boolean>

	^ holder isChanged
]

{ #category : #testing }
BlInfiniteLayoutConstraints >> isItemRemoved [
	"Returns true if the datasource item corresponding to the element I am attached to has been removed from the data set.
	An InfiniteLayout may choose to treat it differently in order to animate its outgoing or disappearing state"
	<return: #Boolean>

	^ holder isRemoved
]

{ #category : #'private - accessing' }
BlInfiniteLayoutConstraints >> pendingInvalidate [
	^ pendingInvalidate
]

{ #category : #'private - accessing' }
BlInfiniteLayoutConstraints >> pendingInvalidate: aBoolean [
	pendingInvalidate := aBoolean
]
